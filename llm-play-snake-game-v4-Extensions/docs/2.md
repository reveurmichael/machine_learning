# before the refactoring

The potential “double-first-move” bug exists because the first element of every LLM plan is executed immediately, while the *rest* of the plan is stored in the snake’s internal queue (`planned_moves`).  
If that first element were left in the queue, the game-loop would execute it **again** on the next tick, and both executions would call `record_move()`, producing:

```json
"moves": ["UP", "UP", "RIGHT", "RIGHT", …]
```

The project eliminates the duplicate in **one single place**—right after the LLM response is parsed and *before* the queue is handed over to the normal planner.

--------------------------------------------------------------------
1.  Where the first execution happens  
`_request_and_execute_first_move()` is called whenever we have just asked the LLM for a new plan:

```python:core/game_loop.py
next_move, game_manager.game_active = get_llm_response(game_manager)
…
# IMPORTANT: prevent duplicate first move
if game_manager.game.planned_moves:
    game_manager.game.planned_moves.pop(0)
```

•  `get_llm_response()` parses the JSON and stores **the full move list** into `game_manager.game.planned_moves`.  
•  A split-second later the first move (`next_move`) is executed.  
•  The `pop(0)` immediately removes that same element from `planned_moves`, so it can never be executed a second time in `_execute_next_planned_move()`.

--------------------------------------------------------------------
2.  How a single execution becomes a single log entry  
Execution path for *any* move, including the first one:

```
GameController.make_move()      # physical movement
└── GameData.record_move()      # holistic stat wrapper
    └── RoundManager.round_buffer.add_move()  # append once
```

`RoundBuffer.moves` therefore contains each move exactly once.  
When `RoundManager.sync_round_data()` or `flush_buffer()` runs, the code simply appends that list into JSON:

```python:core/game_rounds.py
current_round_dict.setdefault("moves", []).extend(self.round_buffer.moves)
```

Because `add_move()` was called once, `.extend()` adds it once.

--------------------------------------------------------------------
3.  Other guard-rails that help keep things unique

| What could go wrong? | Where it is prevented |
|----------------------|-----------------------|
| LLM retries send the **same** plan again → would duplicate planned list | `RoundManager.record_planned_moves()` **overwrites** `planned_moves` instead of extending, so duplicates never accumulate. |
| Parser/LLM fails and we inject an `EMPTY` sentinel, then the normal EMPTY logic runs again → double­-EMPTY | Flag `game_manager.skip_empty_this_tick` is set inside `communication_utils` to skip the fallback `_handle_no_move()` for that tick. |
| Accidentally popping the wrong element | Pop occurs **immediately** in the same function that already has `next_move`, so there’s no risk of a mismatch. |

--------------------------------------------------------------------
4.  What to watch out for when modifying the code

1. **Do NOT remove or relocate the `pop(0)`**.  
   If you move that line into another function, any early return or exception could cause the list to remain unchanged and create duplicates.

2. **Do NOT call `record_move()` (or touch `RoundBuffer.moves`) anywhere else for the same move.**

3. **Adding new sentinel paths?**  
   Make sure they follow the same pattern: only one call to `record_*_move()` per tick and set `skip_empty_this_tick` if they might collide with `_handle_no_move()`.

As long as the "`pop-after-parse` then `add_move` once" discipline is preserved, every round in `game_N.json → detailed_history → rounds_data → X` will have a clean, duplicate-free `moves` array:

```json
"moves": ["FIRST_MOVE", "SECOND_MOVE", "THIRD_MOVE", …]
```


