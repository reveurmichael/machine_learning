# before the refactoring

Of course. Here is a highly detailed breakdown of the round increment logic, including which files are responsible for each step and where the design is most fragile.

### The Core Principle: One LLM Request == One Round

The entire system is built on a simple, strict invariant: **a "round" begins the moment we ask the LLM for a new plan, and it ends when that plan is fully executed.** This ensures that the number of rounds in the final `game_N.json` file always matches the number of `prompt`/`response` files saved in the logs.

---

### The Life-Cycle of a Round: A Step-by-Step Walkthrough

Here is how the modules collaborate to manage the round count.

#### 1. The Source of Truth: `RoundManager` in `core/game_rounds.py`

The authoritative round counter lives here and *only* here. It is a simple integer that starts at 1.

The **only way** to increment the counter is by calling `start_new_round()`. This method is the gatekeeper for all round changes.

```python:core/game_rounds.py
class RoundManager:
    """Collect and persist per-round data throughout a game."""

    def __init__(self) -> None:
        self.round_count: int = 1
        self.rounds_data: Dict[int, dict] = {}
        # ...
        self.round_buffer: Optional[RoundBuffer] = RoundBuffer(number=1)

    def start_new_round(self, apple_position: Optional[Sequence[int] | NDArray]) -> None:
        """Flush the current buffer, bump the counter and initialise a
        fresh :class:`RoundBuffer` seeded with the given *apple_position*.
        """
        # 1. Persist pending data from the *previous* round before advancing.
        self.flush_buffer()

        # 2. Increment the authoritative counter.
        self.round_count += 1

        # 3. Create a new data buffer for this new round.
        self.round_buffer = RoundBuffer(number=self.round_count)

        # 4. Seed it with the current apple's position.
        self.round_buffer.set_apple(self._to_list_or_none(apple_position))
```

-   **`RoundBuffer` (`core/game_stats.py`)**: This is a temporary data-holding object. It collects the moves and other stats for the *current* round. `flush_buffer()` copies this data into the permanent `rounds_data` dictionary before the buffer is reset.

#### 2. The Orchestrator: `GameManager` in `core/game_manager.py`

While `RoundManager` owns the data, `GameManager` is the only module allowed to *tell* it to advance. It does this through its `increment_round()` method.

```python:core/game_manager.py
    def increment_round(self, reason: str = "") -> None:
        """Increment the round counter and synchronize with game state."""
        # (See "Where things can go wrong" about this guard)
        if self.awaiting_plan:
            return

        if not self.game or not hasattr(self.game, "game_state"):
            return

        gs = self.game.game_state

        # Delegate the actual incrementing to the source of truth.
        gs.round_manager.start_new_round(getattr(self.game, "apple_position", None))

        # Keep a local copy for easy access by UI and loggers.
        self.round_count = gs.round_manager.round_count

        # Make the new, empty round buffer visible to the web UI.
        gs.round_manager.sync_round_data()
        
        print(Fore.BLUE + f"ðŸ“Š Advanced to round {self.round_count} {f'({reason})' if reason else ''}")
```

`GameManager` also provides a cleaner, semantic wrapper called `finish_round()`, which is what the game loop actually calls.

```python:core/game_manager.py
    def finish_round(self, reason: str = "round completed") -> None:
        """Flush buffered round-data and advance to the next round."""
        self.increment_round(reason)
```

#### 3. The Trigger: `game_loop.py`

The main game loop is responsible for *deciding* when a round has finished. It calls `game_manager.finish_round()` in exactly two scenarios:

1.  **The queue of planned moves is empty:**
    ```python:core/game_loop.py
    def _execute_next_planned_move(game_manager: "GameManager") -> None:
        # ...
        next_move = game_manager.game.get_next_planned_move()
        if not next_move:
            # Round finished â€“ flush & ask for a new plan next tick
            game_manager.finish_round()
            game_manager.need_new_plan = True
            # ...
            return
    ```
2.  **The snake eats an apple, AND that was the last move in the plan:**
    ```python:core/game_loop.py
    def _post_apple_logic(game_manager: "GameManager") -> None:
        """Common branch after an apple was eaten â€“ decide if we need a new plan."""
        if game_manager.game.planned_moves:
            # ... still moves left, continue the current round
        else:
            # Plan is now empty, finish the round
            game_manager.finish_round()
            game_manager.need_new_plan = True
    ```

#### 4. The Logger: `communication_utils.py`

Immediately after the round is incremented, the game loop sets `need_new_plan = True`. On the next tick, it calls `get_llm_response()`. This function reads the *current* `round_count` from the `GameManager` to generate the log filenames.

```python:llm/communication_utils.py
def get_llm_response(game_manager: "GameManager"):
    # ...
    # Log the prompt using centralized naming
    prompt_filename = get_prompt_filename(
        game_number=game_manager.game_count+1,
        round_number=game_manager.round_count, # Reads the newly incremented value
        file_type="prompt"
    )
    # ... saves prompt file ...

    # ... gets response ...

    response_filename = get_prompt_filename(
        game_number=game_manager.game_count+1,
        round_number=game_manager.round_count, # Same new value
        file_type="raw_response"
    )
    # ... saves response file ...
```

This sequence guarantees that `game_1_round_5_prompt.txt` is created right after the console prints "Advanced to round 5".

#### 5. What DOESN'T Increment the Round: `game_controller.py` and `game_logic.py`

It is critical that the core game physics do not interfere with round counting.
-   Generating a new apple does **not** start a new round.
-   The snake colliding with a wall or itself does **not** start a new round.

This separation is enforced by having the `GameController` and `GameLogic` classes *only record data*. They never make decisions about advancing rounds. You can see the deliberate removal of this logic in the comments:

```python:core/game_controller.py
    def _generate_apple(self) -> NDArray[np.int_]:
        # ...
        # We do NOT start a new round when an apple is generated
        # Rounds are ONLY tied to LLM communications
        # self.game_state.start_new_round(position)  # This line has been removed
        return position
```

#### 6. Continuation Mode (`main.py`)

When you continue a session, `utils/continuation_utils.py` reads the old `summary.json` to load aggregate statistics (like total score). However, it does **not** restore the `round_count` for the *new* game. The `round_count` for the continued game starts fresh at 1, because you are starting a new game with a new first prompt. The historical round counts are only used for the final session summary.

---

### Where Things Can Go Wrong Easily (Points of Fragility)

The logic is robust but relies on strict adherence to its design. Here are the places where a small change could easily break the entire system.

1.  **Most Likely Mistake: Adding a new call to `finish_round()`**.
    A developer modifying the game physics in `core/game_controller.py` might be tempted to call `game_manager.finish_round()` after an apple is eaten. This would break the "one prompt, one round" rule and cause the log files and JSON summary to fall out of sync. **This is the #1 place to be careful.** The design strictly forbids the game controller from managing rounds.

2.  **The `awaiting_plan` Guard in `GameManager`**.
    The check `if self.awaiting_plan: return` at the top of `increment_round` is crucial. It prevents a scenario where two events might try to finish the round in the same tick, causing a double increment before the LLM has even had a chance to reply. Removing this guard would introduce a race condition.

3.  **Forgetting to `flush_buffer()` on Game Over**.
    When a game ends, `process_game_over()` is responsible for calling `save_game_summary()`, which in turn calls `round_manager.flush_buffer()`. If this flush were forgotten, all the moves from the *very last round* of the game would be missing from `game_N.json`, even though they would exist in the `response` text file.

4.  **Incorrect Order of Operations**.
    The current logic is: `finish_round()` (which increments the counter) -> `need_new_plan = True` -> `get_llm_response()` (which reads the counter). If this order were changed, and `get_llm_response` was called *before* `finish_round`, all log files would be off by one (e.g., the prompt for round 6 would be saved in `...round_5_prompt.txt`).


