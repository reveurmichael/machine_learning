
You are an AI agent controlling a snake in the classic Snake game on a 10×10 grid. Coordinates range from (0,0) at the **bottom-left** to (9,9) at the **top-right**.

You are given the following inputs:
  • Head position: (6, 2) — (x, y) of the snake's head.
  • Current direction: DOWN — One of "UP", "DOWN", "LEFT", "RIGHT", or "NONE".
  • Body cells: [(9, 1), (9, 2), (9, 3), (9, 4), (8, 4), (7, 4), (6, 4), (5, 4), (5, 3), (6, 3)] — List of (x, y) positions occupied by the snake's body (excluding the head).
  • Apple position: (3, 9) — (x, y) coordinate of the apple.

## MOVEMENT RULES:
1. Valid directions: "UP", "DOWN", "LEFT", "RIGHT".
2. Direction vectors: 
   { "UP": (0, 1), "DOWN": (0, -1), "LEFT": (-1, 0), "RIGHT": (1, 0) }
3. The snake **cannot** reverse direction (e.g., if going UP, cannot move DOWN next). If the direction is "NONE", any move is allowed.
4. The snake **dies** if it:
   - Collides with its body (which shifts every step),
   - Moves outside the grid bounds (0 ≤ x < 10, 0 ≤ y < 10).
5. Eating the apple at (3, 9):
   - Increases score by 1.
   - Grows the body by 1 segment (tail doesn't shrink on next move).

## COORDINATE SYSTEM:
- UP = y + 1
- DOWN = y - 1
- RIGHT = x + 1
- LEFT = x - 1

Example Moves from (1,1):
  • UP → (1,2)
  • DOWN → (1,0)
  • RIGHT → (2,1)
  • LEFT → (0,1)

## OBJECTIVE:
Plan a safe path for the head to reach the apple, avoiding collisions. Output a JSON object whose "moves" field is a sequence of moves that leads the head now at (6, 2) to eat the apple at (3, 9).  

## REQUIRED OUTPUT FORMAT:
Return a **JSON object** in this **exact format**:

{
  "moves": ["MOVE1", "MOVE2", ...],
  "reasoning": "..." 
}

* "moves" must be a list of valid directions unless the apple is reachable in fewer.
* "reasoning" must be a brief explanation (1–2 sentences) of the path-planning rationale.
* If **no safe path** moves exists, return:

{ "moves": [], "reasoning": "NO_PATH_FOUND" }


## CONSTRAINTS:

* Must not reverse direction on the first move.
* Avoid collisions with walls and body.
* After eating the apple, avoid traps—ensure there's at least one legal move afterward.
* Use Manhattan distance as a heuristic, but prioritize safety.
* Snake movement update (per move):

  * New head = head + direction
  * Head becomes body segment
  * Tail is removed **unless** apple is eaten (in that case, tail remains)

## FINAL POSITION CHECK:

Make sure the total number of LEFT/RIGHT and UP/DOWN moves matches the apple's offset:

* From (6, 2) to (3, 9):

  * x1 ≤ x2 → RIGHTs - LEFTs = x2 - x1
  * x1 > x2 → LEFTs - RIGHTs = x1 - x2
  * y1 ≤ y2 → UPs - DOWNs = y2 - y1
  * y1 > y2 → DOWNs - UPs = y1 - y2
    → In your case: the number of LEFT moves, minus, the number of RIGHT moves, should be equal to 3 (= 6 - 3), and the number of UP moves, minus, the number of DOWN moves, should be equal to 7 (= 9 - 2)

## EDGE CASES TO CONSIDER:

* If apple is behind current direction, detour safely.
* If snake has no body, go directly toward apple.
* Avoid hugging walls unnecessarily, especially near apple.

Now, analyze the game state and return the JSON output. Return only a valid JSON object in the exact format:
{
  "moves": ["MOVE1", "MOVE2", ...],
  "reasoning": "..." 
}

