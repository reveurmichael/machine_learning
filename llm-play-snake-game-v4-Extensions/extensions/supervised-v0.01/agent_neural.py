#!/usr/bin/env python3
"""
Neural Network Agent for Supervised Learning
============================================

PyTorch-based neural network agent that learns from heuristic algorithm demonstrations.
Supports multiple architectures and can be trained on datasets generated by heuristics-v0.03.

This agent demonstrates how supervised learning can capture the decision-making patterns
of expert heuristic algorithms and potentially generalize beyond their capabilities.

Design Patterns:
- Strategy Pattern: Different network architectures (MLP, CNN, RNN)
- Template Method Pattern: Common training/evaluation pipeline with architecture-specific implementations
- Factory Pattern: Network creation based on configuration
"""

from __future__ import annotations

import sys
from pathlib import Path

# Add project root to path for imports
current_dir = Path(__file__).parent
project_root = current_dir.parent.parent  # Go up to project root
sys.path.insert(0, str(project_root))

import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from typing import Dict, List, Tuple, Optional, Any
from abc import ABC, abstractmethod

# Import Task-0 base classes
from core.game_agents import BaseAgent


class NeuralNetworkBase(nn.Module, ABC):
    """
    Abstract base class for neural network architectures.
    
    Implements the Template Method pattern - defines the common interface
    while allowing subclasses to implement architecture-specific details.
    """
    
    def __init__(self, input_size: int, hidden_size: int = 256, num_classes: int = 4):
        """
        Initialize base neural network.
        
        Args:
            input_size: Size of input features
            hidden_size: Size of hidden layers
            num_classes: Number of output classes (4 for UP, DOWN, LEFT, RIGHT)
        """
        super().__init__()
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.num_classes = num_classes
        
    @abstractmethod
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass through the network."""
        pass
    
    def predict_move(self, state: np.ndarray) -> str:
        """
        Predict the best move for a given game state.
        
        Args:
            state: Game state as numpy array
            
        Returns:
            Move as string ("UP", "DOWN", "LEFT", "RIGHT")
        """
        self.eval()
        with torch.no_grad():
            # Convert to tensor
            if isinstance(state, np.ndarray):
                state_tensor = torch.FloatTensor(state).unsqueeze(0)
            else:
                state_tensor = state.unsqueeze(0) if state.dim() == 1 else state
            
            # Get predictions
            logits = self.forward(state_tensor)
            predicted_class = torch.argmax(logits, dim=1).item()
            
            # Convert to move string
            moves = ["UP", "DOWN", "LEFT", "RIGHT"]
            return moves[predicted_class]


class MLPNetwork(NeuralNetworkBase):
    """
    Multi-Layer Perceptron for tabular game state data.
    
    Best suited for engineered features from tabular datasets.
    Simple but effective architecture for learning from heuristic demonstrations.
    """
    
    def __init__(self, input_size: int, hidden_size: int = 256, num_classes: int = 4, dropout: float = 0.3):
        """
        Initialize MLP network.
        
        Args:
            input_size: Size of input features
            hidden_size: Size of hidden layers
            num_classes: Number of output classes
            dropout: Dropout probability for regularization
        """
        super().__init__(input_size, hidden_size, num_classes)
        
        self.network = nn.Sequential(
            nn.Linear(input_size, hidden_size),
            nn.ReLU(),
            nn.Dropout(dropout),
            
            nn.Linear(hidden_size, hidden_size // 2),
            nn.ReLU(),
            nn.Dropout(dropout),
            
            nn.Linear(hidden_size // 2, hidden_size // 4),
            nn.ReLU(),
            nn.Dropout(dropout),
            
            nn.Linear(hidden_size // 4, num_classes)
        )
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass through MLP."""
        return self.network(x)


class CNNNetwork(NeuralNetworkBase):
    """
    Convolutional Neural Network for board state data.
    
    Processes the game board as a 2D image, learning spatial patterns
    that are important for navigation and planning.
    """
    
    def __init__(self, board_size: int = 10, num_classes: int = 4, dropout: float = 0.3):
        """
        Initialize CNN network.
        
        Args:
            board_size: Size of the game board (assumes square board)
            num_classes: Number of output classes
            dropout: Dropout probability for regularization
        """
        # Calculate input size for the linear layer after convolutions
        conv_output_size = self._calculate_conv_output_size(board_size)
        super().__init__(conv_output_size, 256, num_classes)
        
        self.board_size = board_size
        
        # Convolutional layers
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, padding=1)  # 3 channels: snake, apple, empty
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.conv3 = nn.Conv2d(64, 128, kernel_size=3, padding=1)
        
        # Pooling and normalization
        self.pool = nn.MaxPool2d(2, 2)
        self.batch_norm1 = nn.BatchNorm2d(32)
        self.batch_norm2 = nn.BatchNorm2d(64)
        self.batch_norm3 = nn.BatchNorm2d(128)
        
        # Fully connected layers
        self.fc1 = nn.Linear(conv_output_size, 256)
        self.fc2 = nn.Linear(256, 128)
        self.fc3 = nn.Linear(128, num_classes)
        
        self.dropout = nn.Dropout(dropout)
    
    def _calculate_conv_output_size(self, board_size: int) -> int:
        """Calculate the output size after convolutions."""
        # After conv1 + pool: size // 2
        # After conv2 + pool: size // 4
        # After conv3: same size (no pooling)
        size_after_pools = board_size // 4
        return 128 * size_after_pools * size_after_pools
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass through CNN."""
        # Reshape input to board format if needed
        if x.dim() == 2:
            batch_size = x.size(0)
            # Assume input is flattened board + additional features
            board_features = x[:, :self.board_size * self.board_size * 3]
            x = board_features.view(batch_size, 3, self.board_size, self.board_size)
        
        # Convolutional layers
        x = self.pool(F.relu(self.batch_norm1(self.conv1(x))))
        x = self.pool(F.relu(self.batch_norm2(self.conv2(x))))
        x = F.relu(self.batch_norm3(self.conv3(x)))
        
        # Flatten for fully connected layers
        x = x.view(x.size(0), -1)
        
        # Fully connected layers
        x = F.relu(self.fc1(x))
        x = self.dropout(x)
        x = F.relu(self.fc2(x))
        x = self.dropout(x)
        x = self.fc3(x)
        
        return x


class RNNNetwork(NeuralNetworkBase):
    """
    Recurrent Neural Network for sequential game data.
    
    Processes sequences of game states to learn temporal patterns
    and long-term planning strategies from heuristic demonstrations.
    """
    
    def __init__(self, input_size: int, hidden_size: int = 256, num_layers: int = 2, 
                 num_classes: int = 4, dropout: float = 0.3, rnn_type: str = "LSTM"):
        """
        Initialize RNN network.
        
        Args:
            input_size: Size of input features per timestep
            hidden_size: Size of hidden state
            num_layers: Number of RNN layers
            num_classes: Number of output classes
            dropout: Dropout probability
            rnn_type: Type of RNN ("LSTM", "GRU", "RNN")
        """
        super().__init__(input_size, hidden_size, num_classes)
        
        self.num_layers = num_layers
        self.rnn_type = rnn_type
        
        # RNN layer
        if rnn_type == "LSTM":
            self.rnn = nn.LSTM(input_size, hidden_size, num_layers, 
                              batch_first=True, dropout=dropout if num_layers > 1 else 0)
        elif rnn_type == "GRU":
            self.rnn = nn.GRU(input_size, hidden_size, num_layers,
                             batch_first=True, dropout=dropout if num_layers > 1 else 0)
        else:
            self.rnn = nn.RNN(input_size, hidden_size, num_layers,
                             batch_first=True, dropout=dropout if num_layers > 1 else 0)
        
        # Output layer
        self.fc = nn.Linear(hidden_size, num_classes)
        self.dropout = nn.Dropout(dropout)
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass through RNN."""
        # x shape: (batch_size, sequence_length, input_size)
        
        # RNN forward pass
        if self.rnn_type == "LSTM":
            rnn_out, (hidden, cell) = self.rnn(x)
        else:
            rnn_out, hidden = self.rnn(x)
        
        # Use the last output for classification
        last_output = rnn_out[:, -1, :]  # (batch_size, hidden_size)
        
        # Apply dropout and final linear layer
        output = self.dropout(last_output)
        output = self.fc(output)
        
        return output


class NeuralAgent(BaseAgent):
    """
    Neural network-based agent that learns from heuristic demonstrations.
    
    Extends Task-0's BaseAgent to provide a consistent interface while
    using learned policies instead of hand-coded algorithms.
    
    Design Pattern: Strategy Pattern
    - Can use different neural network architectures
    - Pluggable training and evaluation strategies
    - Consistent interface with other agents
    """
    
    def __init__(self, network: NeuralNetworkBase, device: str = "cpu"):
        """
        Initialize neural agent.
        
        Args:
            network: The neural network to use for decision making
            device: Device to run the network on ("cpu" or "cuda")
        """
        super().__init__()
        self.network = network.to(device)
        self.device = device
        self.name = f"Neural-{network.__class__.__name__}"
        
        # Statistics for performance tracking
        self.total_predictions = 0
        self.correct_predictions = 0
        self.prediction_times = []
    
    def get_move(self, game_state: Dict[str, Any]) -> str:
        """
        Get the next move using the neural network.
        
        Args:
            game_state: Current game state dictionary
            
        Returns:
            Move as string ("UP", "DOWN", "LEFT", "RIGHT", or "NO_PATH_FOUND")
        """
        try:
            import time
            start_time = time.time()
            
            # Extract features from game state
            features = self._extract_features(game_state)
            
            # Get prediction from network
            move = self.network.predict_move(features)
            
            # Track performance
            prediction_time = time.time() - start_time
            self.prediction_times.append(prediction_time)
            self.total_predictions += 1
            
            return move
            
        except Exception as e:
            print(f"Error in neural agent prediction: {e}")
            return "NO_PATH_FOUND"
    
    def _extract_features(self, game_state: Dict[str, Any]) -> np.ndarray:
        """
        Extract features from game state for neural network input.
        
        This method converts the game state into the format expected by the network.
        The exact format depends on the network architecture and training data structure.
        
        Args:
            game_state: Current game state dictionary
            
        Returns:
            Feature array suitable for network input
        """
        # Basic feature extraction (can be extended based on network type)
        snake_positions = game_state.get("snake_positions", [(5, 5)])
        apple_position = game_state.get("apple_position", (7, 7))
        score = game_state.get("score", 0)
        steps = game_state.get("steps", 0)
        grid_size = game_state.get("grid_size", 10)
        
        head_position = snake_positions[0] if snake_positions else (5, 5)
        
        # Create basic features
        features = [
            score / 100.0,  # Normalized score
            steps / 1000.0,  # Normalized steps
            len(snake_positions) / 100.0,  # Normalized snake length
            head_position[0] / float(grid_size),  # Normalized head x
            head_position[1] / float(grid_size),  # Normalized head y
            apple_position[0] / float(grid_size),  # Normalized apple x
            apple_position[1] / float(grid_size),  # Normalized apple y
        ]
        
        # Add distance features
        distance_to_apple = np.sqrt((head_position[0] - apple_position[0])**2 + 
                                   (head_position[1] - apple_position[1])**2)
        manhattan_distance = abs(head_position[0] - apple_position[0]) + abs(head_position[1] - apple_position[1])
        
        features.extend([
            distance_to_apple / (grid_size * 1.414),  # Normalized Euclidean distance
            manhattan_distance / (2 * grid_size),     # Normalized Manhattan distance
        ])
        
        # Add wall distances
        wall_distances = [
            (grid_size - 1 - head_position[1]) / float(grid_size),  # Distance to top
            head_position[1] / float(grid_size),                    # Distance to bottom
            head_position[0] / float(grid_size),                    # Distance to left
            (grid_size - 1 - head_position[0]) / float(grid_size),  # Distance to right
        ]
        features.extend(wall_distances)
        
        # Create board representation for CNN networks
        if isinstance(self.network, CNNNetwork):
            board = np.zeros((grid_size, grid_size, 3), dtype=np.float32)
            
            # Mark snake positions
            for i, pos in enumerate(snake_positions):
                if 0 <= pos[0] < grid_size and 0 <= pos[1] < grid_size:
                    board[pos[0], pos[1], 0] = 1.0  # Snake body
                    if i == 0:
                        board[pos[0], pos[1], 1] = 1.0  # Snake head
            
            # Mark apple position
            if 0 <= apple_position[0] < grid_size and 0 <= apple_position[1] < grid_size:
                board[apple_position[0], apple_position[1], 2] = 1.0  # Apple
            
            # Flatten board and combine with other features
            board_flat = board.flatten()
            features = np.concatenate([board_flat, features])
        
        return np.array(features, dtype=np.float32)
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get performance statistics for the neural agent.
        
        Returns:
            Dictionary containing performance metrics
        """
        avg_prediction_time = np.mean(self.prediction_times) if self.prediction_times else 0.0
        
        return {
            "agent_type": "neural",
            "network_type": self.network.__class__.__name__,
            "total_predictions": self.total_predictions,
            "average_prediction_time": avg_prediction_time,
            "device": self.device,
        }


def create_neural_agent(
    network_type: str = "MLP",
    input_size: int = None,
    hidden_size: int = 256,
    device: str = "cpu",
    **kwargs
) -> NeuralAgent:
    """
    Factory function to create neural agents with different architectures.
    
    Args:
        network_type: Type of network ("MLP", "CNN", "RNN", "LSTM", "GRU")
        input_size: Size of input features (calculated automatically for CNN)
        hidden_size: Size of hidden layers
        device: Device to run on ("cpu" or "cuda")
        **kwargs: Additional arguments for specific network types
        
    Returns:
        Configured NeuralAgent instance
    """
    if network_type == "MLP":
        if input_size is None:
            raise ValueError("input_size must be specified for MLP networks")
        network = MLPNetwork(input_size, hidden_size, **kwargs)
        
    elif network_type == "CNN":
        board_size = kwargs.get("board_size", 10)
        network = CNNNetwork(board_size, **kwargs)
        
    elif network_type in ["RNN", "LSTM", "GRU"]:
        if input_size is None:
            raise ValueError("input_size must be specified for RNN networks")
        network = RNNNetwork(input_size, hidden_size, rnn_type=network_type, **kwargs)
        
    else:
        raise ValueError(f"Unknown network type: {network_type}")
    
    return NeuralAgent(network, device) 